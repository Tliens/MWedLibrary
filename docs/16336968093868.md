# 数据结构与算法
## 一、链表
- 链表的特点就是递归，可以通过递归的思想遍历、删除节点。
- 凡是递归基本上都可以用迭代来完成
- 通常都会用个头结点方式处理链表

递归分三步走：
- 1.明白函数的意思，处理除当前节点外的其他节点
- 2.找到终止条件
- 3.处理当前节点


203. 移除链表元素 

递归法：

```
class Solution{
    public ListNode removeElements(ListNode head, int val) {
        if (head == nil){
            return head;
        }else{
            head.next = removeElements(head.next,val);
            return head.val == val ? head.next : head;
        }
    }
}
```
该函数的定义为：传入一个头结点，和值，去掉包含该链表中所有节点的值与传入节点值相同的节点。

head.next = removeElements(head.next,val) 就能保证除了head之外所有的节点都满足条件。

我们在处理head节点。

迭代法：
```
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummyHead = new ListNode(0);
        dummyHead.next = head;
        ListNode temp = dummyHead;
        while (temp.next != null){
            if (temp.next.val == val){
                temp.next = temp.next.next;
            }else{
                temp = temp.next;
            }
        }
        return dummyHead.next;
    }
}
```
通常都会有个假的头结点dummyHead，用来保存链表的头结点。

temp节点从dummyHead.next开始遍历，也就是真正的链表开始遍历，如果当前节点的值，和删除值相同，则把当前节点删除，否则，temp就换成下一个。

83. 删除排序链表中的重复元素
```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null || head.next == null){
            return head;
        }else{
            if (head.val == head.next.val){
                ListNode temp = head.next;
                while (temp.next != null && head.val == temp.next.val){
                    temp = temp.next;
                }
                return deleteDuplicates(temp);
            }else{
                head.next = deleteDuplicates(head.next);
                return head;
            }
        }
    }
}
```


```
public ListNode deleteDuplicates(ListNode head) {
        if (head == null || head.next == null){
            return head;
        }else{
            head.next = deleteDuplicates(head.next);
            return head.val == head.next.val ? head.next : head;
        }
    }
```


