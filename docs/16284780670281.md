# iOS底层原理

- 作者：我是熊大 
- 时间：2021.08 
- 代表作品：《今日计划》、《我的小家》、《今日水印相机》、《Playhouse》。

> 本文是进阶高级、资深iOS工程师的美味佳肴，文章大量详细讲解了iOS底层原理以及性能优化经验。是我耗费大量心血完成了，并将继续完善，希望能对国内iOS整体氛围提供微薄之力。另外此文大部分借鉴李明杰老师的《iOS底层原理》的视频课程的内容，大家感兴趣可以去腾讯课堂购买正版。


## 一、性能优化
### 1、内存优化
优化点：

- 1、leaks 检测内存泄露
> leaks 检测原理：分析是否有指向malloc地址的指针，如果没有的话判定位leak；有些现实场景是无法检测出来的，Leaks检测失效。如果二者循环引用，有个全局变量指向其中一个，那么这个时候是无法检测出来的，因为有全局指针间接指向那块内存；对于使用CF创建的对象没有手动释放，这个是容易检测出来的。
- 2、allocation 分析内存
allocation 会hook对象的alloc、new、copy、mutableCopy、delloc方法，计算两次标记的内存变化。
- 3、僵尸对象检测
>  僵尸对象检测原理：hook对象的delloc方法，当对象执行delloc时，将对象的isa指针指向对象ZombieObject，并在实现方法签名以及消息转发函数，这样当原来本应该销毁的对象，又被使用时，就会被记录下来。
- 4、低内存方案：内存映射
> 推荐MMKV，
- 5、设计类时，考虑字节对齐
- 6、利用autoreleasepool，在for循环产生大量局部对象时，考虑使用自动释放池，及时释放对象
> 自动释放池原理：在ARC环境下，对象初始化时，编译器有可能自动使用autorelease管理对象，达到MRC环境下的autorelease的目的，实现延迟释放对象，@autoreleasepool{} 进入时，会执行push函数，把一个标记位入栈，在内部将所有autorelease的对象的地址依次入栈，当退出时，会循环pop，检测栈中对象的引用计数，进行release，如果引用计数为0，则进行析构函数，直到pop到最开始的标记位。autorelease和runloop有关系，它监听了三种runloop状态：进入runloop、runloop即将休眠、退出runloop。进入runloop时，会创建新的自动释放池；当runloop即将休眠时，销毁当前自动释放池，创建一个新的自动释放池；当runloop退出时，销毁当前自动释放池。自动释放池中的autoreleasepoolpage其实是一个双链表结构，能够让对象延迟释放
- 7、选择结构体而非引用类型
> 结构体释放更迅速，函数执行完毕后就被释放，但引用类型有可能会依赖runloop，是否会依赖runloop这和编译器有关系
- 8、图片降采样
> 一张图片解码后的体积与图像宽高有关系，体积（b） = 宽 * 高 * 4，如果一个很大的图片要显示到很小的UIImageView上，直接解码显然会增加内存占用，而且是没必要的，这是使用图片降采样获得一个合适的尺寸是十分有必要的，使用UIGraphicsImageRenderer对图片进行降采样。
```
import func AVFoundation.AVMakeRect
let rect = AVMakeRect(aspectRatio: image.size, insideRect: imageView.bounds)
```
以上代码，可以帮助我们获取到合适的尺寸。

### 2、卡顿优化
- 1、核心：减轻CPU、GPU压力
> 如果要保证帧率60FPS的刷新率，那么16.67ms内就要保证CPU+GPU结束当前帧的计算和绘制，如果没能结束，我们就要去看是CPU耗时过长还是GPU的耗时过长，这里补充个知识点，我们所说的硬解码、软解码指的就是是否支持GPU解码，支持的就是硬解，不支持的就是软解。
- 2、如何减轻GPU压力
> 减少离屏渲染
- 3、卡顿监测
> 卡顿检测原理，runloop如何实现，可不可以检测屏幕刷新率

### 3、电量优化

### 4、网络优化

### 5、包大小优化

### 6、崩溃处理
- 1、崩溃收集
- 2、如何解析符号表
> 每次xcode打包时，都会生成一个dysm，其中包含当前包所有的类名、函数名、行号对应的地址信息，其本质上是一个表。每个定义的符号都有一个对应的值，叫符号值。我们把crash信息中不包含函数名，只包含函数地址，我们可以通过dysm和奔溃信息中的函数地址还原函数名，Xcode有自带工具可以完成这一工作，重新生成一个crash文件。crash文件中包含的UUID必须与dysm的UUID相匹配。还有一款开源工具atos专门用来做符号解析的。很多系统的库的解析其实都已经解析完毕了，系统的符号表在iOS DeviceSupport中。

符号表元素如下所示：
```
<起始地址> <结束地址> <函数> [<文件名:行号>]
```
- 3、常见的崩溃


## 二、内存管理
### 1、Timer 与 CADisplaylink
在苹果的设计里，Timer与CADisplaylink会对target进行强引用，如果不手动释放timer，则会存在循环引用内存不释放？可以通过leaks工具检测出来。我们可以通过利用设计模式中的结构型模式中的代理模式，打破相互强引用的状态，有两种实现方式：

第一种：

target 引用 timer

创建一个中间代理类P，类P中有个weak修饰的属性变量id

timer 强引用 p对象，p对象弱引用target

此时就达到了打破相互引用的目的，与此同时，类P中还得实现消息转发，直接在forwardtarget方法中返回target。

第二种：

其实第一种办法，效率相对较低，他会先查找方法列表，找不到selector时，才会执行消息转发。但是还有一个和NSObject同级别的类NSProxy，专门用于消息转发，不会查方法列表。

我们可以直接重写方法签名，以及转发对象

CADisplaylink 与屏幕的刷新率保持一致，可以间接设置selector调用的时间间隔，并不准确。

其实NSTimer、CADisplaylink依赖runloop，runloop每执行一圈都会尝试通知timer，但是runloop执行的时长是不固定的，极有可能出现时间不准确的情况。回顾一下runloop的执行流程：

1、通知observer即将进入runloop

2、通知observer即将处理timer

3、通知observer即将处理source

4、处理block

5、处理source0

6、处理souce1，如果有source，跳到第8步

7、通知observer即将进入休眠，等待唤醒

8、通知observer即将被唤醒

    - 1、处理timer
    - 2、处理GCD Anysnc To Main Queue
    - 3、处理source1

9、处理block

10、根据前面执行的结果，决定如何操作
    - 1、回到第二步
    - 2、退出Runloop

11、通知observer退出runloop


### 2、GCDTimer
由于时间精度不准确，所以我们对经度有要求，可以使用GCDTimer，比如在做音视频相关项目时，为了保证一些字幕、贴纸、动效等相关功能，能够跟上时间线，我们就会使用GCDTimer。

GCDTimer并不依赖runloop，它是内核级别的函数，我猜测底层利用的应该是CPU的嘀嗒数，其实本质就是和物理晶振周期差不多的东西。

具体使用办法：

```

```

> 小结：介绍了NSTimer与CADisplaylink，原理与使用时的注意事项，利用代理模式和消息转发实现打破循环引用，回顾了runloop的执行步骤，以及更准确的定时器GCDTimer

### 2、iOS程序的内存布局
从低地址到高地址依次是：保留段、数据段、堆、栈、内核区。

其中数据段又分为：字符串常量、已初始化数据、未初始化数据

栈的生长方向是向下的，也就是地址越来越小

堆的生长方向是向上的，也就是越长越大。

### 3、TaggedPointer

iOS引入了tagged pointer的概念，用于优化NSNumber、NSString、NSData等小对象的存储

在没有以前，一个NSNumber初始化后，会开辟一个8字节的指针，用于指向的具体的数值的地址，对于比较小的数来讲，比如：10，这样做有点浪费空间，还不如直接在指针中存放数值10，于是就有了tagged pointer，指针里边的数据变成了：tag + data，当数据不够用时，才会分配额外的存储空间，变成真正的pointer。

objc_msgSend能识别TaggedPointer，比如从NSNumber的intValue方法，直接从指针中提取数据。

在iOS中如果地址的最高有效位为1，就是taggedpointer；mac则是最低位为1，就是taggedpointer。

有了taggedpointer，意味着，很多小的NSString对象是同一个，地址不会变。


### 4、OC对象的内存管理
iOS的内存管理是用引用计数来标记的，一个对象的引用计数为0时，OC对象就会销毁，释放它的内存空间。

retain函数会让对像的引用计数+1，release函数会让对象的引用计数减一。

当调用alloc、new、copy、mutableCopy时创建一个对象，在不使用是需要调用哪个release或者autorelease来进行销毁。

在ARC环境下，编译器会自动生成retain、release、autorelease；

``` Objective-C

```
属性的set方法大概是这样

```
- (void)setName:(NSString*)name{
    if (_name != name){
        [_name release];
        _name = name;
        [name retain];
    }
}
```
所以在多线程中，容易出现 [_name release]; 同时被执行性多次的情况，导致release过度，出现崩溃。因此这里需要加一把锁。或者保证原子性。


可以通过调用私用函数打印自动释放池：
```
extern void _objc_autoreleasePoolPrint(void);
```
以上代码直接在需要使用的类中声明就可以。

我们会得到AutoReleasePoolPage的详细情况。

### 5、copy、mutableCopy

二者皆是拷贝副本的意思，但有本质区别，copy得到的是一个不可变副本，mutableCopy得到的是可变副本；而副本的意思是编辑原对象不对副本产生音响，编辑副本不对原对象产生影响；一般我们会在声明属性变量时会使用到copy，ARC环境下的MallocBlock也会自动调用copy。

iOS中的可变对象包含：NSMutableString、NSMutableArray、NSMutableDictionary、NSMutableSet.

可变对象的copy得到的全部都是不可变副本，因为原来对象是可变的，为了保证副本的不可变性，需要深拷贝。

可变对象的mutableCopy得到的全部都是可变副本，因为原来对象是可变的，为了保证副本的可变性与原对象独立，需要深拷贝。

不可变对象的copy得到的全部都是不可变副本，因为原来对象是不可变的，为了优化性能和内存，只需要浅拷贝。

不可变对象的mutableCopy得到的全部都是可变副本，因为原来对象是不可变的，为了保证副本的可变性，需要深拷贝。

### 6、引用计数的存储
对象的引用计数存储在对象的isa指针中，以及sideTable中。

回归下，isa指针的结构，它的结构和内存管理十分密切

``` Swift
union isa_t
{
    Class cls;
    uintptr_t bits;
    struct{
        uintptr_t nonpointer    :1;
        uintptr_t has_assoc     :1;
        uintptr_t has_cxx_dtor  :1;
        uintptr_t shiftcls      :33;
        uintptr_t magic         :6;
        uintptr_t weakly_referenceed :1;
        uintptr_t dellocating   :1;
        uintptr_t has_sidetable_rc        :1;
        uintptr_t extra_rc      :19;
    }
}
```
nonpointer 表示是否是优化的指针，如果没优化，则只存放类、原理的地址，一般情况下，都是1，被优化过。

has_assoc 表示是否有关联对象，在对象析构时会被用到，如果没有释放会更快，有的话得去AssociationManager中根据对象的地址去查找，然后释放。

has_cxx_dtor 是否含有C++的析构函数，如果没有回释放的更快

shiftcls 存储着class、metaclass的地址

magic 用于在调试时分辨对象是否未完成初始化

weakly_referenceed 是否有被弱引用过，如果没有回释放的更快，如果有则需要时弱引用表中，将所有指向该对象的引用置空。

dellocating 表示是否正在被释放

has_sidetable_rc 引用计数是否存放在sidetable中，一般情况下会存放在extra_rc中，只有引用计数过大时，会存放在表中。

extra_rc 表示引用计数减一

### 7、SideTable

```c++
struct SideTable{
    spinlock_t slock;
    RecountMap refcnts;
    weak_table_t weak_table;
};
```

refcnts 中存放着对象地址、对象引用计数，是一个散列表

### 8、delloc
当一个对象要释放时，会自动调用dealloc，接下来的调用顺序是
- delloc
- _objc_rootDealloc
- rootDealloc
- object_dispose
- objc_destructInstance、free
```
void *objc_destructInstance(id obj)
{
    if (obj){
        bool cxx = obj->has_CxxDtor();
        bool assoc = hasAssociatedObjects();
        
        if (cxx) object_cxxDestruct(obj);//清除成员变量
        if (assoc) _object_remove_asscoatios(obj);//清除关联对象
        obj->clearDeallocating();//将指向当前对象的弱指针置为nil
    }
    return obj;
}
```
### 9、自动释放池

自动释放池的底层结构是：_AtAutoreleasePool、AutoReleasePoolPage

调用了autorelease的对象，最终都是通过autoreleasepoolpage来管理的

其数据结构如下：
```
class AutoreleasePoolPage{
    magic_t magic;
    id *next;
    pthread_t thread;
    AutoreleasePoolPage *parent;
    AutoreleasePoolPage *child;
    uint32_t depth;
    unit32_t hiwat;
}
```

AutoreleasePoolPage 是一个双链表结构，每个对象占用4096个字节，

调用push方法，会把POOL_BOUNDRY放到 AutoreleasePoolPage 中，

pop时，会从尾部for循环，拿到对象的内存地址，直到找到最近的POOL_BOUNDRY停止。
```
///
@autoreleasepool{//push
    @autoreleasepool{//push

    }//pop
}//pop
```
如果当前页满了，则创建一个新的。

next指向下一个可存放的地址。
### 10、Notification 原理

## 三、多线程

### 1、同步、异步、串行、并发概念
同步和异步的区别是：是否具有开辟线程的能力。

同步，不具备开辟线程的能力。

异步，具备开辟线程的能力。

串行和并发的区别是：任务的执行方式。

串行：一个任务执行完毕之后，另一个任务在执行。

并发：多个任务同时执行。

### 2、多线程锁死的情况分析

只有在当前队列下，而且当前队列是串行的，同步执行任务时才会发生锁死的情况。



### 3、多线程中的锁
主要分为自旋锁和互斥锁。

自旋锁的特点，一直重试，不会休眠。

互斥锁的特点，一旦遇到对象被锁住了，会休眠一段时间，然后继续加锁。

自旋锁因为不断重试的特点，会出现优先级翻转。而互斥锁则会休眠，让出时间片，给低优先级的先用。

自旋锁：spinlock
互斥锁：pthread、NSLock、递归锁、@synchnized、条件锁、信号量等

#### spinlock为什么不安全
spinlock为自旋锁，多线程使用过程中，一旦出现优先级翻转，就会锁死，没办法打开。

#### @synchnized原理

#### 递归锁原理

#### 条件锁使用

### 4、多线程中的同步方案

### 5、多线程的隐患
联系编译器与ARC进行分析

### 6、GCD

### 7、NSOperation

### 8、NSThread

## 四、Runloop
Runloop会保证程序持续运行，并且有休息、唤醒机制


### 1、Runloop 的执行流程

### 2、Runloop 内部实现原理

### 3、Runloop 与线程的关系

### 4、Runloop 与NSTimer的关系

### 5、Runloop 与检测线程卡顿

### 6、Runloop 与自动释放池


## 五、Runtime
### 1、Runtime中的isa详细分析
### 2、Runtime中的方法
### 3、Runtime 消息机制
### 4、super、class
### 5、LLVM中间代码
### 6、API
#### 1、类
#### 2、成员变量
#### 3、方法
### 7、objc_getclass、object_getClass

## 六、OC语法

### 1、对象的本质
oc代码，底层都是c/c++实现的。oc对象底层就是基于c/c++数据结构实现的。

oc代码转c++代码：

```
xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp
```

NSObject 会转化成 struct NSObject_IMPL c++类型的结构体。

NSObject_IMPL中包含一个isa指针，isa指针的类型为Class，Class其实就是object_class的别名。

一个isa指针占用8字节。

#### 1、sizeof、class_getInstanceSize、malloc_size 区别
/// 获取的是示例对象的成员变量所占用的大小
class_getInstanceSize([NSObject class]) //8

/// obj 分配的大小，iOS内存大小必须是16字节对齐
malloc_size((__brigdge const void *)obj) //16

/// 类型占用内存大小 是在编译期确定的值
sizeof(struct Person); //8
断点查看内存，Debug->Debug Workflow->View Memory

iOS是小端模式，从后往前读取。

int类型占用4字节

#### 2、成员变量（实例变量）与属性的区别（-> 和 .）

通过@property声明的属性，会自动生成一个以下划线开头的成员变量

成员变量，默认对外不可见，可以通过关键字@public修饰，让其课件，但是属性可以是对外可见的

属性可以重写set、get方法，.方法就是set方法，改变属性后与之关联的成员变量也会自动修改，反之亦然

通过 class_copyIvarList 可以以获取类的所有成员变量

通过 class_copyPropertyList 可以以获取类的所有属性变量

OC中->用于访问成员变量，.用于访问属性

#### 3、objc_getClass、object_getClass、[self class]、class_isMetaClass
- class  返回对象本身类型

- objc_getClass
```
    Class c1 = objc_getClass("Person");
```
传入字符串，获取到类型

- object_getClass 返回 isa 指向的地址

- class_isMetaClass 用于判断类是否为元类

#### 4、isKindOfClass 原理

- 获取对象isa指向的类，和传入的Class对比
- 遍历对象isa指向类的父类，和传入的Class对比

- 类对象
    - 元类 VS Class
    - 遍历：类的父类 VS Class
- 实例对象
    - 类 VS Class
    - 遍历：类的父类 VS Class
```
void isKindOfClassDemo(){ 
    BOOL re1 = [(id)[NSObject class] isKindOfClass:[NSObject class]]; 
    BOOL re2 = [(id)[LGPerson class] isKindOfClass:[LGPerson class]]; 
    NSLog(@"NSObject类对象：%hhd", re1); //  1
    NSLog(@"LGPerson类对象：%hhd", re2); //  0
    BOOL re3 = [(id)[NSObject alloc] isKindOfClass:[NSObject class]]; 
    BOOL re4 = [(id)[LGPerson alloc] isKindOfClass:[LGPerson class]]; 
    NSLog(@"NSObject实例对象：%hhd", re3); // 1
    NSLog(@"LGPerson实例对象：%hhd", re4); // 1
}
作者：叶秋主
链接：https://juejin.cn/post/6993196067185491998
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### 5、isMemberOfClass 原理
```
+ (BOOL)isMemberOfClass:(Class)cls { 
    return self->ISA() == cls; 
} 
- (BOOL)isMemberOfClass:(Class)cls { 
    return [self class] == cls; 
}
```

- 类方法：获取类的元类，和传入的cls对比
- 实例方法：获取对象所属的类，和传入的cls对比

```
void isMemberOfClassDemo(){ 
    BOOL re1 = [(id)[NSObject class] isMemberOfClass:[NSObject class]]; 
    BOOL re2 = [(id)[LGPerson class] isMemberOfClass:[LGPerson class]]; 
    NSLog(@"NSObject类对象：%hhd", re1); //0
    NSLog(@"LGPerson类对象：%hhd", re2); //0
    BOOL re3 = [(id)[NSObject alloc] isMemberOfClass:[NSObject class]]; 
    BOOL re4 = [(id)[LGPerson alloc] isMemberOfClass:[LGPerson class]]; 
    NSLog(@"NSObject实例对象：%hhd", re3); //1
    NSLog(@"LGPerson实例对象：%hhd", re4); //1
}

作者：叶秋主
链接：https://juejin.cn/post/6993196067185491998
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
### 2、对象的种类
对象对象

类对象

元类对象

### 3、isa 与 supreclass
#### 1、结构梳理
对象的isa指向类、类的isa指向元类

类的supreclass指向父类

元类的superclass指向根元类

NSObject的元类isa指向自己

NSObject的元类的superclass指向NSObject类

对象的方法列表存储在类中

类的方法列表存储在元类中

这意味着，在NSObject中写一个对象方法，可以通过NSObject的类方法找到
#### 2、结构信息

![WX20210829-131841](https://i.loli.net/2021/08/29/147AhWIJDybQHjg.png)

struct class{

}

### 4、KVO
kvo 并不会强引用对象，如果对象被销毁时，再次触发kvo，会导致像一个空指针发送消息，导致崩溃

所以需要在不使用是移除监听。

#### 0、触发时机
- 自动触发
- 手动触发

#### 1、原理：isa交换

#### 2、销毁

因为KVO，保存observer时，使用的是关联对象的方式，所以销毁时需要清除关联对象。



#### 3、如何自己实现一个
1、利用runtime生成一个继承于当前类的子类，名字叫NSKVONOtification_Person

2、拿到当前类的isa指针，利用runtime，使得当前的isa指针指向新创建的类

3、在新的类中重写set方法，并在方法中增加

willChangeValueForKey 

原来的set方法

didChangeValueForKey


#### 4、多次监听同一个对象的属性，为什么会回调多次？不移除监听会怎样？
```
OBJC_ASSOCIATION_ASSIGN: 赋值
OBJC_ASSOCIATION_RETAIN_NONATOMIC: 强引用，非原子操作
OBJC_ASSOCIATION_COPY_NONATOMIC: 先 copy，然后强引用
OBJC_ASSOCIATION_RETAIN: 强引用，原子操作
OBJC_ASSOCIATION_COPY: 先 copy，然后强引用，原子操作
```
动态生成的类，会将observer作为关联对象，保存到生成的类中，并且关联对象使用的策略是OBJC_ASSOCIATION_ASSIGN。

objc_setAssociatedObject(self, (__bridge const void *)@"objc", observer, OBJC_ASSOCIATION_ASSIGN);

KVO会对每一个observer进行分发，不移除，可能会导致崩溃

#### 5、KVO添加和移除的次数不匹配会崩溃吗？
KVO的注册方法和移除方法应该是成对的，如果重复调用移除方法，就会抛出异常NSRangeException并导致程序Crash


#### 6、数组可以使用KVO吗？

监听集合对象变化时，需要通过KVC的mutableArrayValueForKey:等可变代理方法获得集合代理对象，并使用代理对象进行操作，当代理对象的内部对象发生改变时，会触发KVO的监听方法。集合对象包含NSArray和NSSet。

#### 7、如何控制自动触发机制

可以在被观察对象的类中重写

+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key

方法来控制KVO的自动触发

#### 8、防止多次注册和移除相同的 KVO

#### 9、KVO 的依赖观察

https://juejin.cn/post/6844903972528979976#heading-18

第一种办法：

```
+ (NSSet<NSString *> *)keyPathsForValuesAffectingValueForKey:(NSString *)key
{
    NSSet *keyPaths = [super keyPathsForValuesAffectingValueForKey:key];
    if ([key isEqualToString:@"downloadProgress"]) {
        NSArray *affectingKeys = @[@"writtenData",@"totalData"];
        keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys];
    }
    return keyPaths;
}

```

第二种办法：
实现一个遵循命名规则为keyPathsForValuesAffecting<Key>的类方法，<Key>是依赖于其他值的属性名（首字母大写）：
```
+ (NSSet<NSString *> *)keyPathsForValuesAffectingDownloadProgress
{
    return [NSSet setWithObjects:@"writtenData",@"totalData", nil];
}
```
#### 10、实现一个函数，带有block的KVO，使用Block作为会调

### 5、KVC
#### 1、set、get的方法族
#### 2、与KVO的关系
### 6、Category
#### 0、结构

![16302144773483](https://i.loli.net/2021/08/29/hAOQbvBL3MgCHkK.jpg)


#### 1、分类的加载时机、顺序

通过Runtime加载某个类的所有Category数据

把所有Category的方法、属性、协议数据，合并到一个大数组中
后面参与编译的Category数据，会在数组的前面

将合并后的分类数据（方法、属性、协议），插入到类原来数据的前面

#### 2、+load、initalize
 
##### 1、+load方法会在runtime加载类、分类时调用

每个类、分类的+load，在程序运行过程中只调用一次

- 调用顺序
    - 1、先调用类的+load
        按照编译先后顺序调用（先编译，先调用）
        调用子类的+load之前会先调用父类的+load

    - 2、再调用分类的+load
        按照编译先后顺序调用（先编译，先调用）



##### 2、+initialize方法会在类第一次接收到消息时调用

- 调用顺序
    - 1、先调用父类的+initialize，再调用子类的+initialize
        - (先初始化父类，再初始化子类，每个类只会初始化1次)
    - 2、+initialize和+load的很大区别是，+initialize是通过objc_msgSend进行调用的，所以有以下特点
        - 如果子类没有实现+initialize，会调用父类的+initialize（所以父类的+initialize可能会被调用多次）
        - 如果分类实现了+initialize，就覆盖类本身的+initialize调用



#### 3、分类有什么作用
1、不改变原有类的情况下，进行扩展

2、暴露库的私有方法


### 7、关联对象
#### 1、关联对象原理

全局有何关联对象管理类，每个类都有一个关联对象表，表中key值为唯一值，value中保存着关联对象的值和关联对象的策略

![WX20210829-123441](https://i.loli.net/2021/08/29/pUuBmwrlYfsQtDo.png)


#### 2、如何解除关联对象
关联一个空值，就可以解除关联对象

#### 3、如何关联一个weak对象

#### 4、常用的关联对象的key的方式
```swift
static void *MyKey = &MyKey;
objc_setAssociatedObject(obj, MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)
objc_getAssociatedObject(obj, MyKey)

static char MyKey;
objc_setAssociatedObject(obj, &MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)
objc_getAssociatedObject(obj, &MyKey)

使用属性名作为key
objc_setAssociatedObject(obj, @"property", value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
objc_getAssociatedObject(obj, @"property");

使用get方法的@selecor作为key
objc_setAssociatedObject(obj, @selector(getter), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)
objc_getAssociatedObject(obj, @selector(getter))

````
### 8、block
#### 0、block本质

block本质就是个OC对象

```
struct __main_block_impl_0{
    struct __block_impl impl;
    struct __main_block_desc_0 *desc;
    int age;
};

```

```
struct __block_impl{
    void *isa;
    int Flags;
    int Reserved;
    void *FuncPtr;
};
```

```
struct __main_block_desc_0{
    size_t reserved;//0
    size_t Block_size;//结构体大小
};
```

FuncPtr是函数指针中保存函数执行的地址，我们执行block时，实际上是执行FuncPtr指向的函数。
#### 1、block变量捕获机制
为了保证block能够正常访问外部变量，block有个自动捕获机制

- 局部自动变量：auto、离开作用域就会销毁、直接捕获值、值传递
- 局部静态变量：static、捕获指针、指针传递
- 全局变量：不会捕获到block内部，直接访问

当block内部访问了对象类型的auto变量时：

如果block在栈上，将不会对auto变量产生强引用

如果block被拷贝到堆上时，会调用block内部的copy函数，copy函数内部会调用_Block_object_assign函数

_Block_object_assign会根据auto变量的修饰符（__strong、__weak、__unsafe_unretained）做出适应的操作，行程弱引用或者强引用。

如果block从堆中移除

会调用block内部的dispose函数

dispose内部会调用_Block_object_dispose函数

_Block_object_dispose函数会自动释放引用的auto变量




#### 2、block的类型

block 有三种类型：GlobalBlock、MallocBlock、StackBlock
- MallocBlock: __NSSStackBlock__ 调用了copy
- GlobalBlock: 没有访问auto变量,无论什么情况下都不会变成mallocBlock
- StackBlock: 访问了auto变量，只在MRC下存在，ARC环境下block会自动copy [block copy]，变成Malloc

每一种类型的block，调用copy后的结果如下：
- Malloc  引用计数+1
- statck 变成 malloc
- global 什么也不做

#### 3、block的copy
在ARC环境下，block会自动将栈上的block复制到堆上，比如以下情况：
- block作为函数参数返回值时
- 将block赋值给__strong指针时
- block作为cocoaAPI中方法名含有usingBlock的方法参数时
- block作为GCDAPI的方法参数时

#### 3、如何获取一个block的类型
根据 isa指针、或者class方法

[block class]

#### 4、__block
__block 可以用于解决block内部无法修改auto变量值得问题

__block 不能修饰全局变量，静态变量

编译器会将__block变量包装成一个对象，比如：int age

```
struct __Block_byref_age_0 {
    void *__isa;
    __Block_byref_age_0 *__forwarding;//指向block地址
    int __flags;
    int __size;
    int age;
};
```

  

在ARC环境下，block会被自动拷贝到堆中，所以需要用copy修饰对象，即使使用strong修饰block对象也没有关系，最终都会执行copy。

__block 关键字会将对象包装成block对象，该block对象内部包含一个指针指向原本对象，因此我们可以修改该对象。

__weak 关键字也会将达到__block的效果，但是__weak不会对对象的引用计数发生改变。

#### 5、block的内存管理
block内部有两个函数分别是：copy和dispose,用于管理对象的内存地址。

当block内部访问了对象类型的auto变量时：

如果block在栈上，将不会对auto变量产生强引用

如果block被拷贝到堆上时，会调用block内部的copy函数，copy函数内部会调用_Block_object_assign函数

_Block_object_assign会根据auto变量的修饰符（__strong、__weak、__unsafe_unretained）做出适应的操作，行程弱引用或者强引用。

如果block从堆中移除

会调用block内部的dispose函数

dispose内部会调用_Block_object_dispose函数

_Block_object_dispose函数会自动释放引用的auto变量


#### 6、block如何捕获变量


### 9、Notifiocation
#### 1、Notifiocation与线程
如何实现跨线程传输
#### 2、方法执行顺序
#### 3、如何实现一个Notification

## 七、界面交互
### 1、响应链与传递链
### 2、渲染树
### 3、核心动画
### 4、弹窗管理
### 5、转场动画

## 八、音视频
### 1、视频缓存原理
### 2、