# Java中的数据结构 队列

Collection-->Queue-->Deque-->LinkedList(实现类)

双端队列 Deque
- 添加 offer(x)
- 移除 poll()
- 判空 isEmpty()

◼ int size(); // 元素的数量 

◼ boolean isEmpty(); // 是否为空 

◼ void clear(); // 清空 

◼ void enQueueRear(E element);

◼ E deQueueFront(); // 从队头出队 

◼ void enQueueFront(E element); 

◼ E deQueueRear(); // 从队尾出队 

◼ E front(); // 获取队列的头元素

◼ E rear(); // 获取队列的尾元素

> 1、232. 用栈实现队列
```
class MyQueue {
    Deque<Integer> inStack;
    Deque<Integer> outStack;

    public MyQueue() {
        inStack = new LinkedList<Integer>();
        outStack = new LinkedList<Integer>();
    }
    
    public void push(int x) {
        inStack.push(x);
    }
    
    public int pop() {
        if (outStack.isEmpty()) {
            in2out();
        }
        return outStack.pop();
    }
    
    public int peek() {
        if (outStack.isEmpty()) {
            in2out();
        }
        return outStack.peek();
    }
    
    public boolean empty() {
        return inStack.isEmpty() && outStack.isEmpty();
    }

    private void in2out() {
        while (!inStack.isEmpty()) {
            outStack.push(inStack.pop());
        }
    }
}
```
> 2、225. 用队列实现栈
```
class MyStack {
    Queue<Integer> queue1;
    Queue<Integer> queue2;

    public MyStack() {
        queue1 = new LinkedList<Integer>();
        queue2 = new LinkedList<Integer>();
    }
    
    public void push(int x) {
        queue2.offer(x);
        while (!queue1.isEmpty()) {
            queue2.offer(queue1.poll());
        }
        Queue<Integer> temp = queue1;
        queue1 = queue2;
        queue2 = temp;
    }
    
    public int pop() {
        return queue1.poll();
    }
    
    public int top() {
        return queue1.peek();
    }
    
    public boolean empty() {
        return queue1.isEmpty();
    }
}

作者：demigodliu
链接：https://leetcode-cn.com/problems/implement-stack-using-queues/solution/wu-tu-guan-fang-tui-jian-ti-jie-yong-dui-63d4/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```