# Java 中的数据结构 - 栈

## Stack
◼ int size(); // 元素的数量 
◼ boolean isEmpty(); // 是否为空◼ void push(E element); 
◼ E pop(); //出栈
◼ E top(); // 获取栈顶元素◼ void clear(); // 清空

Collection-->Queue-->Deque-->LinkedList(实现类)

## Deque
插入元素
- addFirst(): 向队头插入元素，如果元素为空，则发生NPE

- addLast(): 向队尾插入元素，如果为空，则发生NPE

- offerFirst(): 向队头插入元素，如果插入成功返回true，否则返回false

- offerLast(): 向队尾插入元素，如果插入成功返回true，否则返回false

移除元素
- removeFirst(): 返回并移除队头元素，如果该元素是null，则发生NoSuchElementException

- removeLast(): 返回并移除队尾元素，如果该元素是null，则发生NoSuchElementException

- pollFirst(): 返回并移除队头元素，如果队列无元素，则返回null

- pollLast(): 返回并移除队尾元素，如果队列无元素，则返回null

获取元素
- getFirst(): 获取队头元素但不移除，如果队列无元素，则发生NoSuchElementException

- getLast(): 获取队尾元素但不移除，如果队列无元素，则发生NoSuchElementException

- peekFirst(): 获取队头元素但不移除，如果队列无元素，则返回null

- peekLast(): 获取队尾元素但不移除，如果队列无元素，则返回null

栈操作
- pop(): 弹出栈中元素，也就是返回并移除队头元素，等价于removeFirst()，如果队列无元素，则发生NoSuchElementException

- push(x): 向栈中压入元素，也就是向队头增加元素，等价于addFirst()，如果元素为null，则发生NPE，如果栈空间受到限制，则发生IllegalStateException

- peek（）:返回栈首元素，但不进行删除。

> 1、leetcode_20_有效的括号
```
 public boolean isValid(String s) {
    int n = s.length();
    if (n % 2 == 1) {
        return false;
    }

    Map<Character, Character> pairs = new HashMap<Character, Character>() {{
	            put(')', '(');
	            put(']', '[');
	            put('}', '{');
	        }};
    Deque<Character> stack = new LinkedList<Character>();
        for (int i = 0; i < n; i++) {
	            char ch = s.charAt(i);
	            if (pairs.containsKey(ch)) {
	                if (stack.isEmpty() || stack.peek() != pairs.get(ch)) {
	                    return false;
	                }
	                stack.pop();
	            } else {
	                stack.push(ch);
	            }
        }
    return stack.isEmpty();
}
```
> 2、leetcode_856_括号的分数
```
public int scoreOfParentheses(String s) {
        Stack<Integer> stack = new Stack<Integer>();
        stack.push(0);
        for (char c: s.toCharArray()) {
            if (c == '('){
                stack.push(0);
            }else{
                Integer now = stack.pop();
                Integer last = stack.pop();
                stack.push(last + Math.max(now*2 , 1));
            }
        }
        return stack.pop();
    }
```
> 3、leetcode_150_逆波兰表达式求值
```
public int evalRPN(String[] tokens) {
        Stack<Integer> stack = new Stack<Integer>();
        for (String c:tokens ){
            if (!isNumber(c)){
                int num2 = stack.pop();
                int num1 = stack.pop();
                switch (c) {
                    case "+":
                        stack.push(num1 + num2);
                        break;
                    case "-":
                        stack.push(num1 - num2);
                        break;
                    case "*":
                        stack.push(num1 * num2);
                        break;
                    case "/":
                        stack.push(num1 / num2);
                        break;
                    default:
                }
            }else{
                stack.push(Integer.parseInt(c));
            }
        }
        return stack.peek();
    }
    public boolean isNumber(String token) {
        return !("+".equals(token) || "-".equals(token) || "*".equals(token) || "/".equals(token));
    }
```
> 4、leetcode_224_基本计算器
```
class Solution {
    public int calculate(String s) {
        Deque<Integer> ops = new LinkedList<Integer>();
        ops.push(1);
        int sign = 1;

        int ret = 0;
        int n = s.length();
        int i = 0;
        while (i < n) {
            if (s.charAt(i) == ' ') {
                i++;
            } else if (s.charAt(i) == '+') {
                sign = ops.peek();
                i++;
            } else if (s.charAt(i) == '-') {
                sign = -ops.peek();
                i++;
            } else if (s.charAt(i) == '(') {
                ops.push(sign);
                i++;
            } else if (s.charAt(i) == ')') {
                ops.pop();
                i++;
            } else {
                long num = 0;
                while (i < n && Character.isDigit(s.charAt(i))) {
                    //num * 10 两位数，或者多位数处理,
                    //s.charAt(i) - '0'利用Ascii码的性质
                    num = num * 10 + s.charAt(i) - '0';
                    i++;
                }
                ret += sign * num;
            }
        }
        return ret;
    }
}
```
`(`入栈的作用便是因为多位数计算
