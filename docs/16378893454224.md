# Java中的数据结构 二叉树

>1、二叉树的前序遍历
递归
```
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        LinkedList<Integer> list = new LinkedList<Integer>();
        if (root == null){
            return list;
        }
        return my_preorderTraversal(root,list);
    }
    public List<Integer> my_preorderTraversal(TreeNode root,LinkedList<Integer> list){
        if (root == null){
           return list;
        }
        list.offer(root.val);
        
        my_preorderTraversal(root.left,list);
        my_preorderTraversal(root.right,list);
        return list;
    }
}
```
//迭代
```
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        LinkedList<Integer> list = new LinkedList<Integer>();
        if (root == null){
            return list;
        }
        return my_preorderTraversal(root,list);
    }
    public List<Integer> my_preorderTraversal(TreeNode root,LinkedList<Integer> list){
        LinkedList<TreeNode> stack = new LinkedList<TreeNode>();
        TreeNode node = root;
        stack.push(node);
        while (!stack.isEmpty() || node != null){
            while (node != null){
                list.offer(node.val);
                stack.push(node);
                node = node.left;
            }
            node = stack.pop();
            node = node.right;
        }
        return list;
    }
}
```
所有的递归都隐藏维护了一个栈，我们可以用栈+迭代得出结果。

希望对函数调用栈有所启发。

>2、二叉树的中序遍历

/// 递归
```
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {

        LinkedList<Integer>list = new LinkedList<Integer>();
        help_inorderTraversal(root,list);
        return list;
    }
    public void help_inorderTraversal(TreeNode root,LinkedList<Integer> list) {
        if (root == null){
            return;
        }
        help_inorderTraversal(root.left,list);
        list.offer(root.val);
        help_inorderTraversal(root.right,list);
    }
}
```
/// 迭代
```
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {

        LinkedList<Integer>list = new LinkedList<Integer>();
        help_inorderTraversal(root,list);
        return list;
    }
    public void help_inorderTraversal(TreeNode root,LinkedList<Integer> list) {
        if (root == null){
            return;
        }
        
        LinkedList<TreeNode> stack = new LinkedList<TreeNode>();
        TreeNode node = root;
        while(!stack.isEmpty() || node != null){

            while(node != null){
                stack.push(node);
                node = node.left;
            }
            
            node = stack.pop();
            list.offer(node.val);
            node = node.right;
        }

    }
}
```

>3、二叉树的后序遍历
// 递归
```
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        LinkedList<Integer> list = new LinkedList<Integer>();
        help_postorderTraversal(root,list);
        return list;
    }
    public void help_postorderTraversal(TreeNode root,LinkedList<Integer> list) {
        if (root == null){
            return;
        }
        help_postorderTraversal(root.left,list);
        help_postorderTraversal(root.right,list);
        list.offer(root.val);
    }
}
```
// 迭代
```
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        LinkedList<Integer> list = new LinkedList<Integer>();
        help_postorderTraversal(root,list);
        return list;
    }
    public void help_postorderTraversal(TreeNode root,LinkedList<Integer> list) {
        if (root == null){
            return;
        }
        LinkedList<TreeNode> stack = new LinkedList<TreeNode>();
        TreeNode node = root;
        TreeNode prev = null;
        while(!stack.isEmpty() || node != null){
            while(node != null){
                stack.push(node);
                node = node.left;
            }
            node = stack.pop();
            if (node.right == null || node.right == prev){
                list.offer(node.val);
                prev = node;
                node = null;
            }else{
                stack.push(node);
                node = node.right;
            }
        }
    }
}
```

后续遍历就像葡萄剪枝，先找到最左，最下的节点，剪下来，然后找根节点，根节点右边若为空，或者根节点右边已经被剪下来了，就剪下根节点，被剪的元素标记为prev。

>4、二叉树的层序遍历
```
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        LinkedList<TreeNode> queue = new LinkedList<TreeNode>();
        if (root == null){
            return res;
        }
        queue.offer(root);
        while(!queue.isEmpty()){

            int size = queue.size();
            List<Integer> temp = new ArrayList<Integer>();
            for(int i = 0;i<size;i++){
                TreeNode node = queue.poll();
                temp.add(node.val);
                if (node.left != null){
                    queue.offer(node.left);
                }
                if (node.right != null){
                    queue.offer(node.right);
                }
            }
            res.add(temp);
        }
        return res;
    }
}
```