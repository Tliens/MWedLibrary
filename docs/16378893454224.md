# Java中的数据结构 二叉树

>1、二叉树的前序遍历
递归
```
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        LinkedList<Integer> list = new LinkedList<Integer>();
        if (root == null){
            return list;
        }
        return my_preorderTraversal(root,list);
    }
    public List<Integer> my_preorderTraversal(TreeNode root,LinkedList<Integer> list){
        if (root == null){
           return list;
        }
        list.offer(root.val);
        
        my_preorderTraversal(root.left,list);
        my_preorderTraversal(root.right,list);
        return list;
    }
}
```
//迭代
```
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        LinkedList<Integer> list = new LinkedList<Integer>();
        if (root == null){
            return list;
        }
        return my_preorderTraversal(root,list);
    }
    public List<Integer> my_preorderTraversal(TreeNode root,LinkedList<Integer> list){
        LinkedList<TreeNode> stack = new LinkedList<TreeNode>();
        TreeNode node = root;
        stack.push(node);
        while (!stack.isEmpty() || node != null){
            while (node != null){
                list.offer(node.val);
                stack.push(node);
                node = node.left;
            }
            node = stack.pop();
            node = node.right;
        }
        return list;
    }
}
```
所有的递归都隐藏维护了一个栈，我们可以用栈+迭代得出结果。

希望对函数调用栈有所启发。

>2、二叉树的中序遍历

/// 递归
```
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {

        LinkedList<Integer>list = new LinkedList<Integer>();
        help_inorderTraversal(root,list);
        return list;
    }
    public void help_inorderTraversal(TreeNode root,LinkedList<Integer> list) {
        if (root == null){
            return;
        }
        help_inorderTraversal(root.left,list);
        list.offer(root.val);
        help_inorderTraversal(root.right,list);
    }
}
```
/// 迭代
```
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {

        LinkedList<Integer>list = new LinkedList<Integer>();
        help_inorderTraversal(root,list);
        return list;
    }
    public void help_inorderTraversal(TreeNode root,LinkedList<Integer> list) {
        if (root == null){
            return;
        }
        
        LinkedList<TreeNode> stack = new LinkedList<TreeNode>();
        TreeNode node = root;
        while(!stack.isEmpty() || node != null){

            while(node != null){
                stack.push(node);
                node = node.left;
            }
            
            node = stack.pop();
            list.offer(node.val);
            node = node.right;
        }

    }
}
```

>3、二叉树的后序遍历
// 递归
```
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        LinkedList<Integer> list = new LinkedList<Integer>();
        help_postorderTraversal(root,list);
        return list;
    }
    public void help_postorderTraversal(TreeNode root,LinkedList<Integer> list) {
        if (root == null){
            return;
        }
        help_postorderTraversal(root.left,list);
        help_postorderTraversal(root.right,list);
        list.offer(root.val);
    }
}
```
// 迭代
```
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        LinkedList<Integer> list = new LinkedList<Integer>();
        help_postorderTraversal(root,list);
        return list;
    }
    public void help_postorderTraversal(TreeNode root,LinkedList<Integer> list) {
        if (root == null){
            return;
        }
        LinkedList<TreeNode> stack = new LinkedList<TreeNode>();
        TreeNode node = root;
        TreeNode prev = null;
        while(!stack.isEmpty() || node != null){
            while(node != null){
                stack.push(node);
                node = node.left;
            }
            node = stack.pop();
            if (node.right == null || node.right == prev){
                list.offer(node.val);
                prev = node;
                node = null;
            }else{
                stack.push(node);
                node = node.right;
            }
        }
    }
}
```

后续遍历就像葡萄剪枝，先找到最左，最下的节点，剪下来，然后找根节点，根节点右边若为空，或者根节点右边已经被剪下来了，就剪下根节点，被剪的元素标记为prev。

>4、二叉树的层序遍历
```
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        LinkedList<TreeNode> queue = new LinkedList<TreeNode>();
        if (root == null){
            return res;
        }
        queue.offer(root);
        while(!queue.isEmpty()){

            int size = queue.size();
            List<Integer> temp = new ArrayList<Integer>();
            for(int i = 0;i<size;i++){
                TreeNode node = queue.poll();
                temp.add(node.val);
                if (node.left != null){
                    queue.offer(node.left);
                }
                if (node.right != null){
                    queue.offer(node.right);
                }
            }
            res.add(temp);
        }
        return res;
    }
}
```

>5、二叉树的最大深度
// 递归

```
class Solution {
    public int maxDepth(TreeNode root) {
        return help_maxDepth(root,0);
    }
    public int help_maxDepth(TreeNode root,int depth) {
        if(root == null){
            return depth;
        }
        int left_depth = help_maxDepth(root.left,depth);
        int right_depth = help_maxDepth(root.right,depth);
        return Integer.max(left_depth,right_depth) + 1;
    }

}
```
处理当前节点之后的。

// 递归 + 队列
```
class Solution {
    public int maxDepth(TreeNode root) {
        return help_maxDepth(root,0);
    }
    public int help_maxDepth(TreeNode root,int depth) {
        if(root == null){
            return depth;
        }
        LinkedList<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root);
        
        while(!queue.isEmpty()){
            int size = queue.size();
            for (int i =0;i<size;i++){
                TreeNode node = queue.poll();
                if (node.left != null){
                    queue.offer(node.left);
                }
                if (node.right != null){
                    queue.offer(node.right);
                }
            }
            depth += 1;
        }
        return depth;
    }

}
```

能否用递归 + 栈 完成呢？

>6、二叉树的层次遍历二
```
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> ret = new ArrayList<List<Integer>>();
        LinkedList<TreeNode> queue = new LinkedList<TreeNode>();
        if (root == null){
            return ret;
        }
        queue.offer(root);
        while(!queue.isEmpty()){
            int size = queue.size();
            List<Integer> temp = new ArrayList<Integer>();
            for(int i =0;i<size;i++){
                TreeNode node = queue.poll();
                temp.add(node.val);
                if (node.left != null){
                    queue.offer(node.left);
                }
                if (node.right != null){
                    queue.offer(node.right);
                }
            }
            ret.add(0,temp);
        }
        return ret;
    }
}
```
这次是从底向上打印，只需要每次插入在第一个位置就行了。

>7、二叉树的最大宽度
// 新的数据结构
```
class Solution {
    public int widthOfBinaryTree(TreeNode root) {
        LinkedList<NoteTreeNode> queue = new LinkedList<NoteTreeNode>();
        int ret = 0;
        int curDepth = 0;
        int left = 0;
        if (root == null){
            return ret;
        }
        NoteTreeNode noteNode = new NoteTreeNode(root,0,0);
        queue.offer(noteNode);
        while(!queue.isEmpty()){
            NoteTreeNode a = queue.poll();
            if (a.node != null){
                queue.offer(new NoteTreeNode(a.node.left,a.depth+1,a.pos*2));
                queue.offer(new NoteTreeNode(a.node.right,a.depth+1,a.pos*2+1));
                if (curDepth != a.depth){
                    curDepth = a.depth;
                    left = a.pos;
                }
                ret = Integer.max(ret,a.pos - left + 1);
            }
        }
        return ret;
    }
    
}
class NoteTreeNode{
        TreeNode node;
        int depth,pos;
        NoteTreeNode(TreeNode n,int d,int p){
            node = n;
            pos = p;
            depth = d;
        }
}
```

/// 字典+前序遍历
```
class Solution {
    int ans;
    Map<Integer, Integer> left;
    public int widthOfBinaryTree(TreeNode root) {
        ans = 0;
        left = new HashMap();
        dfs(root, 0, 0);
        return ans;
    }
    public void dfs(TreeNode root, int depth, int pos) {
        if (root == null) return;
        left.computeIfAbsent(depth, x-> pos);
        ans = Math.max(ans, pos - left.get(depth) + 1);
        dfs(root.left, depth + 1, 2 * pos);
        dfs(root.right, depth + 1, 2 * pos + 1);
    }
}
```

>7、N叉树的前序遍历
```
class Solution {
    public List<Integer> preorder(Node root) {
        ArrayList list = new ArrayList();
        return help_preorder(root,list);
    }

    public List<Integer> help_preorder(Node root,ArrayList list) {
        if (root == null){
            return list;
        }
        list.add(root.val);
        for (Node children : root.children){
            help_preorder(children,list);
        }
        return list;
    }
}
```
/// 递归
```
class Solution {
    public List<Integer> preorder(Node root) {
        ArrayList list = new ArrayList();
        return help_preorder(root,list);
    }

    public List<Integer> help_preorder(Node root,ArrayList list) {
        if (root == null){
            return list;
        }
        LinkedList<Node> stack = new LinkedList<Node>();
        stack.push(root);


        while (!stack.isEmpty()){
            Node cur = stack.pop();
            list.add(cur.val);
            Collections.reverse(cur.children);
            for (Node n : cur.children){
                stack.push(n);
            }
        }
        return list;
    }
}
```
>8、N叉树的后序遍历
```
class Solution {
    public List<Integer> postorder(Node root) {
        LinkedList<Integer> res = new LinkedList<>();
        if (root == null) {
            return res;
        }

        Deque<Node> stack = new ArrayDeque<>();
        stack.addLast(root);
        while (!stack.isEmpty()) {
            Node node = stack.removeLast();
            res.addFirst(node.val);
            for (int i = 0; i < node.children.size(); i++) {
                stack.addLast(node.children.get(i));
            }
        }
        return res;
    }
}

```
>9、N叉树的最大深度

/// 层序遍历 递归
```
class Solution {
    public int maxDepth(Node root) {
        LinkedList<Node> queue = new LinkedList<Node>();
        int ret = 0;
        if (root == null){
            return ret;
        }
        queue.offer(root);
        while(!queue.isEmpty()){
            int size = queue.size();
            for (int i = 0; i<size; i++){
                Node temp = queue.poll();
                for (Node node :temp.children){
                    queue.offer(node);
                }
            }
            ret += 1;
        }
        return ret;
    }
}

```
/// 迭代
```
class Solution {
    public int maxDepth(Node root) {
        int ret = 0;
        if (root == null){
            return ret;
        }
        for (Node children : root.children){
            int depth = maxDepth(children);
            ret = Math.max(ret,depth);
        }
        return ret+1;
    }
}
```

>10、二叉树展开为链表
```
class Solution {
    public void flatten(TreeNode root) {
        List<TreeNode> list = new ArrayList<TreeNode>();

        LinkedList<TreeNode> stack = new LinkedList<TreeNode>();
        if (root == null){
            return;
        }
        stack.push(root);
        TreeNode node = root;
        while(!stack.isEmpty()){
            while (node != null){
                list.add(node);
                stack.push(node);
                node = node.left;
            }
            node = stack.pop();
            node = node.right;
        }
        int size = list.size();
        for (int i = 1; i < size; i++) {
            TreeNode prev = list.get(i - 1), curr = list.get(i);
            prev.left = null;
            prev.right = curr;
        }
    }
}
```
```
class Solution {
    public void flatten(TreeNode root) {
        List<TreeNode> list = new ArrayList<TreeNode>();
        preorderTraversal(root, list);
        int size = list.size();
        for (int i = 1; i < size; i++) {
            TreeNode prev = list.get(i - 1), curr = list.get(i);
            prev.left = null;
            prev.right = curr;
        }
    }

    public void preorderTraversal(TreeNode root, List<TreeNode> list) {
        if (root != null) {
            list.add(root);
            preorderTraversal(root.left, list);
            preorderTraversal(root.right, list);
        }
    }
}

```
> 11、从中序与后序遍历序列构造二叉树
中序遍历：左根右
后序遍历：左右根

拿到后续遍历的根节点，将中序遍历分为左、右，循环拿取遍历，一定要是先构建右子树，再构建左。
```
class Solution {
    int post_index;
    int[] postorder;
    Map<Integer,Integer> idx_map = new HashMap<Integer,Integer>();
    

    public TreeNode helper(int in_left, int in_right){
        if (in_left > in_right){
            return null;
        }
        int root_val = postorder[post_index];
        TreeNode root = new TreeNode(root_val);

        int in_index = idx_map.get(root_val);
        post_index--;
        root.right = helper(in_index+1,in_right);
        root.left = helper(in_left,in_index-1);
        return root;
    }
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        this.post_index = postorder.length-1;
        this.postorder = postorder;
        int in_index = 0;
        for (Integer val : inorder){
            idx_map.put(val,in_index++);
        }
        return helper(0,inorder.length-1);
    }
}
```
> 12 从前序与中序遍历序列构造二叉树
中序遍历：左根右
前序遍历：根左右

拿到前序遍历的根节点，将中序遍历分为左、右，循环拿取遍历，一定要是先构建左子树，再构建右。

```
class Solution {
    int pre_index;
    int[] preorder;
    Map<Integer,Integer> idx_map = new HashMap<Integer,Integer>();
    

    public TreeNode helper(int in_left, int in_right){
        if (in_left > in_right){
            return null;
        }
        int root_val = preorder[pre_index];
        TreeNode root = new TreeNode(root_val);

        int in_index = idx_map.get(root_val);
        pre_index++;
        root.left = helper(in_left,in_index-1);
        root.right = helper(in_index+1,in_right);
        return root;
    }
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        this.pre_index = 0;
        this.preorder = preorder;
        int in_index = 0;
        for (Integer val : inorder){
            idx_map.put(val,in_index++);
        }
        return helper(0,inorder.length-1);
    }
}
```

> 13 根据前序和后序遍历构造二叉树
前序遍历：根左右
后序遍历：左右根


> 14 对称二叉树

```
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return help_isSymmetric(root.left,root.right);
    }
    public boolean help_isSymmetric(TreeNode left,TreeNode right) {
        if (left == null && right == null){
            return true;
        }
        if (left == null || right == null){
            return false;
        }
        if (left.val == right.val){
            return help_isSymmetric(left.left,right.right) && help_isSymmetric(left.right,right.left);
        }
        return false;
    }
}
```